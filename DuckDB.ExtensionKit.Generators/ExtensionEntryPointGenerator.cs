using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace DuckDB.ExtensionKit.Generators;

[Generator]
public class ExtensionEntryPointGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "DuckDB.ExtensionKit.DuckDBExtensionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Read MSBuild properties
        var buildProperties = context.AnalyzerConfigOptionsProvider
            .Select(static (provider, _) => GetBuildProperties(provider));

        // Find all classes with [DuckDBExtension] attribute
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetClassInfo(ctx))
            .Where(static info => info is not null);

        // Combine class info with build properties
        var combined = classDeclarations.Combine(buildProperties);

        context.RegisterSourceOutput(combined, static (spc, tuple) =>
        {
            var (classInfo, props) = tuple;
            if (classInfo is null) return;

            var source = GenerateEntryPoint(
                classInfo.Value.Namespace,
                classInfo.Value.ClassName,
                props.ExtensionName,
                props.DuckDBVersion);
            spc.AddSource($"{classInfo.Value.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static (string ExtensionName, string DuckDBVersion) GetBuildProperties(AnalyzerConfigOptionsProvider provider)
    {
        provider.GlobalOptions.TryGetValue("build_property.ExtensionName", out var extensionName);
        provider.GlobalOptions.TryGetValue("build_property.DuckDBVersion", out var duckDBVersion);

        return (
            extensionName ?? "extension",
            duckDBVersion ?? "v1.2.0"
        );
    }

    private static (string Namespace, string ClassName)? GetClassInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
            return null;

        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : classSymbol.ContainingNamespace.ToDisplayString();

        return (namespaceName, classSymbol.Name);
    }

    private static string GenerateEntryPoint(string namespaceName, string className, string extensionName, string duckDBVersion)
    {
        var namespaceDeclaration = string.IsNullOrEmpty(namespaceName)
            ? string.Empty
            : $@"namespace {namespaceName};";

        var entryPoint = $"{extensionName}_init_c_api";

        // Ensure version string is properly formatted (add 'v' prefix if missing)
        if (!duckDBVersion.StartsWith("v"))
            duckDBVersion = "v" + duckDBVersion;

        return $@"// <auto-generated/>
#nullable enable
using DuckDB.ExtensionKit;
using DuckDB.ExtensionKit.Native;
using DuckDB.ExtensionKit.NativeMethods;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

{namespaceDeclaration}

public static unsafe partial class {className}
{{
    private static DuckDBExtApiV1 Api;

    [UnmanagedCallersOnly(EntryPoint = ""{entryPoint}"", CallConvs = new[] {{ typeof(CallConvCdecl) }})]
    public static byte Init(nint info, DuckDBExtensionAccess* access)
    {{
        try
        {{
            nint apiPtr;

            var version = ""{duckDBVersion}\0""u8;
            fixed (byte* versionPtr = version)
            {{
                apiPtr = access->GetApi(info, versionPtr);
            }}

            if (apiPtr == 0)
                return 0;

            Api = *(DuckDBExtApiV1*)apiPtr;

            nint* dbPtr = access->GetDatabase(info);
            nint connection;
            if (Api.duckdb_connect(*dbPtr, &connection) != DuckDBState.Success)
            {{
                SetError(access, info, ""Failed to connect to database"");
                return 0;
            }}

            NativeMethods.Api = Api;

            RegisterFunctions(new DuckDBConnection(connection));

            Api.duckdb_disconnect(&connection);
            return 1;
        }}
        catch (System.Exception)
        {{
            return 0;
        }}
    }}

    private static void SetError(DuckDBExtensionAccess* access, nint info, string message)
    {{
        var bytes = Encoding.UTF8.GetBytes(message + '\0');
        fixed (byte* ptr = bytes)
        {{
            access->SetError(info, ptr);
        }}
    }}
}}
    ";
        }
    }
